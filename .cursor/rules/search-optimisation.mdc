---
description: Comprehensive guide to the DIGITCORE search functionality including main search, command menu, page content search, and pattern-specific search features
---

# DIGITCORE Search Architecture - Implementation Guide

*Last Updated: 2025-01-27*  
*Status: Production-ready with multiple search interfaces*

## Project Overview

DIGITCORE is a Next.js 15 application with Sanity CMS featuring comprehensive search functionality across multiple interfaces and content types.

## Search Architecture Overview

### Technology Stack
- **Frontend**: Next.js 15 (App Router), React 18, TypeScript
- **Backend**: Sanity CMS with GROQ queries
- **Search Implementation**: Hybrid client-side and server actions
- **State Management**: React state with Zustand for global state
- **Styling**: Tailwind CSS with shadcn/ui components

### Search Types Implemented

1. **Main Search Page** (`/search`) - Advanced search with filtering
2. **Command Menu** (Cmd+K) - Global search palette 
3. **Page Content Search** - In-page search for pattern pages
4. **Pattern-Specific Search** - Search within individual pattern content

## 1. Main Search Page Architecture

### File Structure
```
src/app/(frontend)/search/page.tsx                    # Main search page (Server Component)
├── src/components/pages/search/
│   ├── search-interface-wrapper.tsx                 # Fetches filter options (Client Component)  
│   ├── search-interface.tsx                         # Search input & filters (Client Component)
│   ├── search-client-wrapper.tsx                    # Search execution & results (Client Component)
│   ├── search-results.tsx                           # Results container (Client Component)
│   ├── search-result-item.tsx                       # Individual result display (Client Component)
│   ├── search-result-skeleton.tsx                   # Loading skeleton
│   └── search-results-header-client.tsx             # Results count header
├── src/app/actions/
│   ├── search.ts                                     # Main search server actions
│   └── filter-options.ts                            # Filter options server action
├── src/lib/
│   ├── search.ts                                     # Search utilities & types
│   └── search-utils.ts                              # Text processing utilities
└── src/sanity/lib/
    ├── queries.ts                                    # GROQ search queries
    └── filter-options.ts                            # Filter option queries
```

### Key Features
- **Advanced Text Search**: GROQ-powered full-text search with relevance scoring
- **Multi-faceted Filtering**: Filter by audiences, themes, and tags
- **Context-aware Truncation**: Smart text truncation preserving search matches
- **Match Highlighting**: Visual highlighting of search terms in results
- **Match Explanation**: Shows where matches were found (title/description)
- **Expandable Descriptions**: Client-side expansion without re-fetch
- **URL State Management**: All search state persists in URL parameters

### Search Parameters Schema
```typescript
// From src/lib/search.ts
export const searchParamsSchema = z.object({
  q: z.string().optional(),                    // Search query string
  audiences: z.string().optional(),            // Comma-separated audience IDs
  themes: z.string().optional(),               // Comma-separated theme IDs  
  tags: z.string().optional(),                 // Comma-separated tag IDs
  page: z.coerce.number().min(1).default(1),   // Pagination
  limit: z.coerce.number().min(1).max(100).default(20)
});
```

### GROQ Query Implementation
```groq
// Enhanced search with scoring - from src/sanity/lib/queries.ts
*[_type == "pattern" && defined(slug.current)
  // Filter applications
  && (!defined($audiences) || count($audiences) == 0 || count((audiences[]._ref)[@ in $audiences]) > 0)
  && (!defined($themes) || count($themes) == 0 || theme._ref in $themes)
  && (!defined($tags) || count($tags) == 0 || count((tags[]._ref)[@ in $tags]) > 0)
]
// Multi-level scoring system
| score(
    boost(title match $searchTerm, 15),                    // Exact title match (highest)
    boost(pt::text(description) match $searchTerm, 12),    // Exact description match
    boost(title match ($searchTerm + "*"), 8),             // Title prefix match
    boost(pt::text(description) match ($searchTerm + "*"), 6), // Description prefix
    title match ($searchTerm + "*"),                       // Basic title scoring
    pt::text(description) match ($searchTerm + "*")        // Basic description scoring
)
[_score > 0] | order(_score desc, title asc)
```

## 2. Command Menu (Global Search)

### Implementation
- **Location**: `src/components/global/command-menu.tsx`
- **Trigger**: Cmd+K / Ctrl+K keyboard shortcut
- **Search Action**: `searchContentForCommandModal()` in `src/app/actions/search.ts`

### Features
- **Cross-content Search**: Searches patterns, solutions, resources, and tags simultaneously
- **Debounced Input**: 300ms debounce for performance
- **Keyboard Navigation**: Full keyboard navigation support
- **Theme Integration**: Respects light/dark theme
- **Page Content Integration**: On pattern pages, also searches page content

### Search Execution
```typescript
// From src/app/actions/search.ts - Command modal search
export async function searchContentForCommandModal(searchTerm: string) {
  // Execute parallel searches across all content types
  const [patternsResult, solutionsResult, resourcesResult, tagsResult] = 
    await Promise.allSettled([
      client.fetch(PATTERN_SIMPLE_SEARCH_QUERY, queryParams),
      client.fetch(SOLUTION_SEARCH_QUERY, queryParams),
      client.fetch(RESOURCE_SEARCH_QUERY, queryParams),
      client.fetch(TAG_SEARCH_QUERY, queryParams),
    ]);
}
```

## 3. Page Content Search

### Implementation
- **Hook**: `src/hooks/use-page-content-search.ts`
- **Store**: `src/stores/page-content.tsx` 
- **Scope**: Pattern pages only

### Features
- **Content Indexing**: Automatically indexes page content (headings, solutions, resources)
- **Client-side Search**: No server requests, instant results
- **Type Prioritization**: Solutions > Resources > Headings > Content
- **Score-based Ranking**: Term matches weighted by location (title vs context)
- **Scroll Integration**: Can scroll to search results within page

### Search Algorithm
```typescript
// From use-page-content-search.ts
const searchTerms = searchQuery.toLowerCase().split(" ");
for (const term of searchTerms) {
  if (titleLower.includes(term)) {
    score += 10; // Higher weight for title matches
    matchedTerms++;
  } else if (contextLower.includes(term)) {
    score += 5;  // Lower weight for context matches
    matchedTerms++;
  }
}
```

## 4. Pattern-Specific Search

### Implementation
- **Server Action**: `src/app/actions/pattern-search.ts`
- **Scope**: Search within a specific pattern's content

### Features
- **Deep Content Search**: Searches pattern title, description, solutions, resources, tags, audiences
- **Nested Solution Search**: Includes solutions nested within resources
- **Server-side Filtering**: Uses GROQ to fetch then filters client-side for flexibility

## Text Processing & UX Enhancements

### Context-Aware Truncation
```typescript
// From src/lib/search-utils.ts
export function truncateWithContext(text: string, searchTerm: string, maxLength = 200) {
  // Centers snippet around search match
  const contextBefore = Math.floor((maxLength - termLength) / 2);
  const start = Math.max(0, matchIndex - contextBefore);
  // Returns with ellipsis indicators and match metadata
}
```

### Search Term Highlighting
```typescript
export function highlightMatches(text: string, searchTerm: string): string {
  const regex = new RegExp(`(${escapedTerm})`, 'gi');
  return text.replace(regex, '<mark class="bg-yellow-200 rounded-sm">$1</mark>');
}
```

### Match Explanation System
- **Visual Indicators**: Shows where matches were found (title/description)
- **Match Count**: Displays number of term occurrences
- **Expandable Content**: Click to see full descriptions with preserved highlighting

## Performance Optimizations

### Request Management
- **Deduplication**: Prevents duplicate searches with identical parameters
- **Abort Controllers**: Cancels in-flight requests when new searches start
- **Conditional Execution**: Only searches when criteria present (no empty searches)
- **Debounced Input**: 300ms debounce across all search interfaces

### Client-Side Processing
- **Zero Server Load**: All text truncation and highlighting done client-side
- **Cacheable Results**: Same GROQ query results cached for all users
- **Optimistic Updates**: Immediate UI feedback for filter changes
- **Memory Management**: Proper cleanup of search state and event listeners

### State Management Patterns

#### Isolated Local State (Critical Pattern)
```typescript
// Fixed pattern from search-interface.tsx - prevents input flickering
const [searchTerm, setSearchTerm] = useState("");
const isInitialized = useRef(false);

useEffect(() => {
  if (!isInitialized.current && currentParams) {
    setSearchTerm(currentParams.searchTerm || "");
    isInitialized.current = true; // One-time initialization only
  }
}, [currentParams]);
```

#### Parameter Management
```typescript
// Always provide all GROQ parameters to prevent "param not provided" errors
const queryParams: Record<string, unknown> = {
  audiences: parsedParams.audiences || [],
  themes: parsedParams.themes || [],
  tags: parsedParams.tags || []
};
```

## Debug & Monitoring System

### Browser Console Integration
```typescript
// Available in browser console - from src/lib/logger.ts
window.searchLogger = {
  dump: () => logger.dumpLogs(),      // View all logs
  export: () => logger.exportLogs(), // Export for analysis
  clear: () => logger.clearLogs(),   // Clear log history
  logs: () => console.table(logger.dumpLogs()) // Tabular view
};
```

### Comprehensive Logging
- **Search Operations**: Complete search flow tracking
- **GROQ Queries**: Query execution times and parameters
- **Component Lifecycle**: Mount/unmount and state changes
- **Error Handling**: Detailed error context and recovery paths

## User Experience Features

### Loading States
- **Smart Skeletons**: Only show loading when actively searching
- **Progressive Enhancement**: Results appear as they load
- **Empty States**: Helpful guidance when no results or no search criteria

### Accessibility
- **Keyboard Navigation**: Full keyboard support across all search interfaces
- **Screen Reader Support**: Proper ARIA labels and announcements
- **Focus Management**: Logical focus flow and visible focus indicators

### Visual Design
- **Match Highlighting**: Yellow highlighting for search terms
- **Match Indicators**: Badges showing where matches were found
- **Expandable Content**: Smooth transitions for content expansion
- **Responsive Design**: Works across all device sizes

## Development Guidelines

### Adding New Search Features

1. **Server Actions**: Add to `src/app/actions/search.ts`
2. **GROQ Queries**: Update `src/sanity/lib/queries.ts` 
3. **Client Components**: Follow isolated state pattern from `search-interface.tsx`
4. **Text Processing**: Use utilities in `src/lib/search-utils.ts`
5. **Logging**: Include comprehensive logging for debugging

### Testing Search Features

1. **Enable Logging**: Use `logger.search()` and `logger.groq()` calls
2. **Browser Console**: `searchLogger.logs()` for tabular view of operations
3. **Component Tracking**: Each component has unique ID for tracing requests
4. **Export Logs**: `searchLogger.export()` for detailed analysis

### Common Patterns

#### Search Component Structure
```typescript
export function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState("");
  const location = createLogLocation("component.tsx", "ComponentName");
  const [componentId] = useState(() => Math.random().toString(36).substring(7));
  
  // Always include comprehensive logging
  logger.debug("client", "Component initialized", { componentId }, location);
  
  // Use isolated state pattern for search inputs
  // Include proper cleanup in useEffect
}
```

#### URL State Management
```typescript
// Use serializeSearchParams for URL updates
const updateURL = useCallback((params: Partial<ParsedSearchParams>) => {
  const newParams = serializeSearchParams({ ...currentParams, ...params });
  router.push(`${pathname}?${newParams.toString()}`);
}, [currentParams, pathname, router]);
```

## Future Enhancement Areas

### Potential Improvements
- **Search Analytics**: Track search terms and result interactions
- **Machine Learning**: Improve relevance scoring based on user behavior
- **Search Suggestions**: Implement autocomplete/typeahead functionality
- **Advanced Filtering**: Add date ranges, content type filters
- **Search Performance**: Monitor and optimize query execution times
- **Faceted Search**: Add saved searches and search history

### Maintenance Monitoring
- **Performance Metrics**: Track search query execution times
- **Error Rates**: Monitor search failure rates and error patterns
- **User Behavior**: Track search patterns and result click-through rates
- **Content Coverage**: Ensure all content types are properly indexed

---

## Quick Reference

### Key Files by Function
- **Main Search**: `src/components/pages/search/search-interface.tsx`
- **Command Menu**: `src/components/global/command-menu.tsx`
- **Page Search**: `src/hooks/use-page-content-search.ts`
- **Server Actions**: `src/app/actions/search.ts`
- **GROQ Queries**: `src/sanity/lib/queries.ts`
- **Text Utils**: `src/lib/search-utils.ts`
- **Types & Schema**: `src/lib/search.ts`

### Debug Commands
```javascript
// In browser console
searchLogger.logs()          // View recent search operations
searchLogger.export()        // Export logs for analysis
searchLogger.clear()         // Clear log history
```

### Performance Considerations
- All search inputs use 300ms debounce
- Client-side text processing (no server load for highlighting/truncation)
- Request deduplication prevents unnecessary API calls
- Optimistic UI updates for better perceived performance
- Proper cleanup prevents memory leaks in long-running sessions